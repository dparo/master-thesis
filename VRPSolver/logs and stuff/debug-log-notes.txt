
main2(args) at /CVRP/src/run.jl:114
    - app["batch"] = nothing
    - run_cvrp(app) at /CVRP/src/run.jl:53
        - Prints application parameters     (The app dict) ::
            - app: Dict{String,Any}("batch" => nothing,"instance" => "/IN/A-n37-k5.vrp","noround" => false,"cfg" => "/CVRP/src/../config/CVRP.cfg","out" => nothing,"ub" => 670.0,"sol" => nothing,"tikz" => nothing,"maxr" => 5,"nosolve" => false,"minr" => 5)
        - readCVRPData(app) at /CVRP/src/data.jl:51
            - Parses the input VRP input file format (CVRPLIB)
        - app["sol"] = nothing  => Solution is not read
        - app["nosolve"] = false => build the model and solve everything
        - build_model(data, app) at /CVRP/src/model.jl:3
            - data is the $(i, j)$ half matrix pair for each customer and depot possible
            - Constructs edges, customers, vehicle cap
            - Calls into VrpModel, returns an empty generic VrpSolver solver for generic problems:
                - A VrpSolver is a solver that can solve a generic alike VRP model as formulated in the first pages of the original paper
                - VrpModel() at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:202
            - Populates the VrpModel (called cvrp)
            - Adds the graph, sets up the vertex packing sets, elementarity sets distance metrix, the capacity cut separator, and branching priority
            - __Installs an edge_ub_callback__ at /CVRP/src/model.jl:62
                - edge_ub_callback at /CVRP/src/model.jl:62
                    - Iterates over the half matrix of valid (i, j) edges.
                    - For each edge that has x[(i,j)] > 1.001, bounds it by adding add_dynamic_constr!
                        - Variable  x[(i, j)] <= 1.0
        - Constructs a VrpOptimizer using the app["cfg"] parameters
            - app["cfg"] points to the configuration file containing all the configurations
            - In VrpOptimizer(user_model, param_file, instance_name) at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:1585
                - Calls into build_optimizer_formulation(user_model) at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:1393
                    - Creates LP variables, LP objectives, LP constraints and formulation
                - Calls into generate_pricing_networks(user_model, user_var_to_vars) at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:1078
                    - Gneerates pricing networks constructs BaPCod networks formulations
                    - Adds resources (main, special and standard), consumptions, add vertices to packing sets and element sets, sets up packing sets distance matrix, adds Ryan-Foster constraint
                - Construts the Dantzig wolfe decomposition
                - Initializes the rcsp_oracle for PP subproblem starting from the pricing networks
                - Calls into  generate_rcsp_oracle_for_dw_sp!(model, sp, gen_rcsp_fct) at /root/.julia/packages/RCSP/YuXpc/src/RCSP.jl:630
                    - dw: stands for Dantzig Wolfe here
                    - Installs a callback that returns a network for solving the RCSP subproblem
                - Sets the multiplicity of the subrpoblems
                - Sets the branching priorities
                - __Adds the callbacks to the optimizer__ from by iterating over optimizer.user_model.callbacks
                    - Adds the following constraints which are generated from user_cb_fct functions:
                        - "edge_ub"
                - Adds the capacity cut separators to the optimizer
                    - Calls into add_rcsp_capacity_cuts! at /root/.julia/packages/RCSP/YuXpc/src/RCSP.jl:586
        - Sets cutoff of the optimizer using app["ub"] parameter
            - app["ub"] = 670.0
            - Clamps the objective function, and sets the ub as a default initial upper bound
        - Calls optimize!(optimizer::VrpOptimizer) at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:1655
            - Constructs a BaPCodSolver, passing some default parameters which overrides the param_file
            - Calls #solve#105(suppress_warnings, ignore_solve_hook, relaxation, kwargs, , m) at /root/.julia/packages/JuMP/I7whV/src/solvers.jl:150
                - Solve shortcicuits and forward the call to the the vrp hook since it is provided from the user/extension:
                    - Calls into #vrp_hook#70(suppress_warnings, relaxation, kwargs, , model) at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:2259
                    - Calls BlockDecomposition.send_to_solver!
                    - Calls #solve#105(suppress_warnings, ignore_solve_hook, relaxation, kwargs, , m) at /root/.julia/packages/JuMP/I7whV/src/solvers.jl:150
                        - But this time ignores the solvehook
                        - Calls #build#108(suppress_warnings, relaxation, traits, , m) at /root/.julia/packages/JuMP/I7whV/src/solvers.jl:299
                        - Calls In optimize!(m) at /root/.julia/packages/BaPCod/32oXZ/src/BaPCodSolverInterface.jl:438
                            - Does not register any Julia genvarcb( since m.solver.genvarcallbacks = [] is an empty list)

            - Calls register_solutions at /root/.julia/packages/VrpSolver/9F7LT/src/VrpSolver.jl:1705
                - Calls BapCod.getstartsolution, BapCod.getnextsolution
            - Prints statistics
            - And sets them inside the optimizer.stats Dictionary
        - Gets the solution and status from the optimize code
        - Prints the solution if it was found, and staus, generates figures and similar stuff



bc_oracles.jl register_oracles
bc_oracles.jl set_oracles
bc_oracles.jl oraclecallback
